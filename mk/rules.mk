#
# rules.mk : set flags and make rules
#

#
# pull in the file search stuff
#
include $(TOPDIR)/mk/paths.mk

PRE_SRCS:=      $(ALL_SRCS)

HC_OPTS        += $(INCFLAGS) $(INC_OPTS) $(HCFLAGS)
HSC_OPTS       += $(INCFLAGS) $(INC_OPTS)
CC_OPTS        += $(INCFLAGS) -optc-O3 $(INC_OPTS)

# If $(way) is set then we define $(way_) and $(_way) from it in the
# obvious fashion.
ifeq "$(way)" "p"
  way_ := $(way)_
  _way := _$(way)
endif

#
# building the profiled way
#
ifeq "$(way)" "p"
PROF_OPTS	= -prof -auto-all -Icbits
LD_OPTS		+= $(PROF_OPTS)
HC_OPTS     += $(PROF_OPTS)
HC_OPTS 	+= -hisuf $(way_)hi -hcsuf $(way_)hc -osuf $(way_)o
endif

# Distclean files (all files generated by configure)
DIST_CLEAN_FILES+= $(PKG).conf.m4.in $(PKG).conf.m4 aclocal.m4 config.log \
  config.status cbits/config.h
DIST_CLEAN_DIRS+= autom4te.cache

#
# Library flags
#
PKG_OPTS       += -package-name $(PKG)
GHCI_LIBRARY    = $(patsubst lib%.a,%.o,$(LIBRARY))

#
# Compute dependencies
#
depend: $(MKDEPENDHS_SRCS) $(C_SRCS)
	@echo "Rebuilding dependencies... "
	@$(RM) depend
	@$(GHC) -M -optdep-f -optdepdepend $(HC_OPTS) $(MKDEPENDHS_SRCS)
	@for x in $(C_SRCS) ; do \
	$(GCC) -MM $(INCFLAGS) "$$x" >> $@; \
	done
	@echo "done."

#
#  boot and all targets
#
.PHONY: boot all lib

boot :: depend

#
# Building libraries from $(LIBOBJS)
#

all :: lib
lib :: $(LIBRARY)

$(LIBRARY) :: $(LIBOBJS)
	$(RM) $@
	$(AR) $(AR_OPTS) $@ $(LIBOBJS)
	$(RANLIB) $@

lib :: $(GHCI_LIBRARY)

$(GHCI_LIBRARY) : $(LIBOBJS)
	$(LD_X) -r -o $@ $(STUBOBJS) $(LIBOBJS)

# No need to define .SUFFIXES because we don't use any suffix rules
# Instead we use gmake's pattern rules exlusively

.SUFFIXES:

# This declaration tells GNU make to delete the target if it has
# changed and the command which created it exited with a non-zero exit
# code.

.DELETE_ON_ERROR:

#
# We anticipate wanting to use multiple ways. Particularly prof.
#

%.$(way_)o: %.hs
	$(GHC) $(HC_OPTS) $(PKG_OPTS) -c $< -o $@ -ohi $(basename $@).$(way_)hi

%.$(way_)o : %.lhs
	$(GHC) $(HC_OPTS) $(PKG_OPTS) -c $< -o $@  -ohi $(basename $@).$(way_)hi

%.$(way_)hi : %.$(way_)o
	@:

%_hsc.c %_hsc.h %.hs : %.hsc
	$(HSC2HS) $(HSC_OPTS) $(SYMS) $<
	@touch $(patsubst %.hsc,%_hsc.c,$<)

%.$(way_)o : %.c
	@$(RM) $@
	$(GHC) $(CC_OPTS) -c $< -o $@

# preprocssed files, for haddock docs
%.raw-hs : %.lhs
	$(GHC) $(HC_OPTS) -D__HADDOCK__ -E -optP-P $< -o $@

%.raw-hs : %.hs
	$(GHC) $(HC_OPTS) -D__HADDOCK__ -E -optP-P $< -o $@


#
# Package creation
#

PKG_PREREQS = $(LIBRARY) $(GHCI_LIBRARY)

# in-tree package.conf
$(PKG).conf: $(PKG).conf.m4 $(PKG_PREREQS)
	@if [ ! -f $(PKG).conf ]; then echo [] > $(PKG).conf ; fi
	@m4 $(PKG).conf.m4 \
	  | sed 's/"",//g; s/, ""//g' \
	  | $(GHC_PKG) --force -f $(PKG).conf -u 
	@$(RM) $(PKG).conf.old

# installable package.conf
$(PKG).conf.install: $(PKG).conf.m4 $(PKG_PREREQS)
	@if [ ! -f $(PKG).conf.install ]; then echo [] > $(PKG).conf.install; fi
	@m4 -D__INSTALLING__ $(PKG).conf.m4 \
	  | sed 's/"",//g; s/, ""//g' \
	  | $(GHC_PKG) --force -f $(PKG).conf.install -u 
	@$(RM) $(PKG).conf.install.old

# (un-)register package.conf (needs usually be done as root
.PHONY: register unregister
register: $(PKG).conf.m4 $(PKG_PREREQS)
	@m4 -D__INSTALLING__ $(PKG).conf.m4 \
	  | sed 's/"",//g; s/, ""//g' \
	  | $(GHC_PKG) -u 

unregister:
	$(GHC_PKG) -r $(PKG)

EXTRA_CLEANS+= $(PKG).conf.install $(PKG).conf

lib :: $(PKG).conf


#
# Building the haddock docs
#
ifneq "$(HADDOCK)" ""

HTML_DIR      = html
HADDOCK_SRCS += $(HS_SRCS)
HS_PPS        = $(addsuffix .raw-hs, \
                        $(filter-out $(basename $(NO_DOCS)), \
                                $(basename $(HADDOCK_SRCS))))

EXTRA_HS_PPS  = $(addsuffix .raw-hs, $(basename $(NO_DOCS)))

CLEAN_FILES     += $(HS_PPS) $(EXTRA_HS_PPS)
CLEAN_DIRS      += $(HTML_DIR)

INSTALL_DATAS  += $(HTML_DIR)

DOC_IFACE1 = html/hscurses.interface1
DOC_IFACE2 = html/hscurses.interface2
DOC_INDEX  = html/index.html

# circular (excluded) modules first
$(DOC_IFACE1): $(EXTRA_HS_PPS)
	@$(INSTALL_DIR) $(HTML_DIR)
	$(HADDOCK) -D $(DOC_IFACE1) -o $(HTML_DIR) $(EXTRA_HS_PPS) -k $(PKG)

$(DOC_INDEX): $(HS_PPS) $(DOC_IFACE1)
	@$(INSTALL_DIR) $(HTML_DIR)
	$(HADDOCK) -D $(DOC_IFACE2) -o $(HTML_DIR) $(HS_PPS) -k $(PKG)
	cd $(HTML_DIR) && $(HADDOCK) -h --gen-index -i `basename $(DOC_IFACE1)` \
	   -i `basename $(DOC_IFACE2)`

.PHONY: doc
html: $(DOC_INDEX)
doc  :: html
all  :: doc
endif


#
# cleaning
#
.PHONY: clean distclean

clean:
	$(RM) $(MOSTLY_CLEAN_FILES) $(EXTRA_CLEANS) $(CLEAN_FILES)
	$(RM) -rf $(CLEAN_DIRS)

distclean :: clean
	$(RM) $(DIST_CLEAN_FILES) *~ */*~
	$(RM) -rf $(DIST_CLEAN_DIRS)

#
# installing
#
# For each of these variables that is defined, you
# get one install rule
#
#       INSTALL_PROGS        executable programs in $(bindir)
#       INSTALL_LIBS         platform-dependent libraries in $(libdir) (ranlib'ed)
#       INSTALL_DATAS        platform-independent files in $(datadir)
#       INSTALL_IFACES       platform-dependent interface files in $(ifacedir)
#

.PHONY: install show-install

INSTALL_IFACES += $(HS_IFACES)
INSTALL_LIBS   += $(LIBRARY) $(GHCI_LIBRARY)

show-install :
	@echo "BINDIR  = $(BINDIR)"
	@echo "LIBDIR  = $(LIBDIR)"
	@echo "DATADIR = $(DATADIR)"
	@echo "INCDIR  = $(INCDIR)"

install :: all

# the sed is to strip any trailing '_' from the inplace bin names.
ifneq "$(INSTALL_PROGS)" ""
install :: $(INSTALL_PROGS)
	@$(INSTALL_DIR) $(BINDIR)
	@for i in $(INSTALL_PROGS); do \
        j=`echo $$i | sed 's/_$$//'` ;\
		echo $(INSTALL_PROGRAM) $(INSTALL_BIN_OPTS) $$i $(BINDIR)/$$j ;\
		$(INSTALL_PROGRAM) $(INSTALL_BIN_OPTS) $$i $(BINDIR)/$$j ;\
	done
endif

ifneq "$(INSTALL_LIBS)" ""
install :: $(INSTALL_LIBS)
	@$(INSTALL_DIR) $(LIBDIR)
	@for i in $(INSTALL_LIBS); do \
		echo $(INSTALL_DATA) $(INSTALL_OPTS) $$i $(LIBDIR) ;\
		$(INSTALL_DATA) $(INSTALL_OPTS) $$i $(LIBDIR) ;\
	done
endif

ifneq "$(INSTALL_DATAS)" ""
install :: $(INSTALL_DATAS)
	@$(INSTALL_DIR) $(DATADIR)
	@for i in $(INSTALL_DATAS); do \
		if [ -d $$i ] ; then \
			echo $(CP) -r $$i $(DATADIR)/ ;\
			$(CP) -r $$i $(DATADIR)/ ;\
		else \
			echo $(INSTALL_DATA) $(INSTALL_OPTS) $$i $(DATADIR)/ ;\
			$(INSTALL_DATA) $(INSTALL_OPTS) $$i $(DATADIR)/ ;\
		fi ;\
	done
endif

ifneq "$(INSTALL_IFACES)" ""
install :: $(INSTALL_IFACES)
	@$(INSTALL_DIR) $(IFACEDIR)
	@for i in $(INSTALL_IFACES); do \
	    $(INSTALL_DIR) $(IFACEDIR)/`dirname $$i` ;\
		echo $(INSTALL_DATA) $(INSTALL_OPTS) $$i $(IFACEDIR)/`dirname $$i`/ ; \
		$(INSTALL_DATA) $(INSTALL_OPTS) $$i $(IFACEDIR)/`dirname $$i`/ ; \
	done
endif

ifneq "$(INSTALL_HEADERS)" ""
install :: $(INSTALL_HEADERS)
	@$(INSTALL_DIR) $(INCDIR)
	@for i in $(INSTALL_HEADERS); do \
		echo $(INSTALL_DATA) $(INSTALL_OPTS) $$i $(INCDIR) ; \
		$(INSTALL_DATA) $(INSTALL_OPTS) $$i $(INCDIR) ; \
	done
endif

install :: $(PKG).conf.install
	@$(INSTALL_DIR) $(LIBDIR)
	$(INSTALL_DATA) $(INSTALL_OPTS) $< $(LIBDIR)/$(PKG).conf

